<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Поток данных</title>
    <link rel="shortcut icon" type="image/x-icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../css/header.css">
    <link rel="stylesheet" href="../../../css/content.css">
    <link rel="stylesheet" href="../../../libraries/prism.css">
    <link rel="stylesheet" href="../../../libraries/font-awesome/css/font-awesome.css">

    <script src="../../../libraries/prism.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="../../../libraries/header.js"></script>
</head>
<body>

<section class="nav-bar">
    <div class="nav-container">
        <div class="brand">
            <a href="index.html"><img src="../../../images/react-logo.png">Теория</a>
        </div>
        <nav>
            <div class="nav-mobile"><a id="nav-toggle" href="#!"><span></span></a></div>
            <ul class="nav-list">
                <li>
                    <a href="../../../index.html">Главная</a>
                </li>
                <li>
                    <a href="../../../labs.html">Лабораторные работы</a>
                </li>
                <li>
                    <a href="../../../theory.html">Теория</a>
                </li>
                <li>
                    <a href="../../../info.html">Справочник</a>
                </li>
            </ul>
        </nav>
    </div>
</section>

<div id="delimiter"></div>

<div class="content">
    <p class="section">Поток данных</p>

    <p>Архитектура Redux вращается вокруг строго однонаправленного потока данных. Это значит, что все данные в
    приложении следуют одному паттерну жизненного цикла, делая логику Вашего приложения более предсказуемой и легкой для
    понимания. Также это способствует большей упорядоченности данных, так что в конечном итоге у Вас не будет нескольких
    изолированных копий одних и тех же данных, которые ничего не знают друг о друге.</p>
    <p>Жизненный цикл данных в любом Redux-приложении включает в себя 4 шага:</p>

    <ol>
        <li><p><b>Вы вызываете store.dispatch(action).</b></p></li>
        <li>
            <p><b>Хранилище Redux вызывает функцию-редюсер, который вы ему передали.</b></p>
            <p>Хранилище передаст два аргумента при вызове редюсера: текущее дерево состояния (current state tree) и
            действие. Например, в todo-приложении главный редюсер может принимать что-то такое:</p>

            <pre><code class="language-jsx">
                // Текущее состояние приложения (список дел и выбранный фильтр)
                let previousState = {
                    visibleTodoFilter: 'SHOW_ALL',
                    todos: [
                        {
                        text: 'Прочитать документы',
                        complete: false
                        }
                    ]
                }

                // Выполнение действия (добавление дела)
                let action = {
                    type: 'ADD_TODO',
                    text: 'Разобрать потоки.'
                }

                // Ваш редюсер возвращает следующее состояние приложения
                let nextState = todoApp(previousState, action)
            </code></pre>

            <p>Обратите внимание на то, что редюсер — это чистая функция. Он только вычисляет следующее состояние. Он
            должен быть совершенно предсказуемым: тип возвращаемых данных не должен меняться, если на вход подаются
            данные одного типа. Он не должен совершать никаких сайд-эффектов, таких как обращение к API или
            маршрутизация по приложению. Все это должно происходить только после того, как действие будет совершено.</p>
        </li>
        <li>
            <p><b>Главный редюсер может комбинировать результат работы нескольких редюсеров в единственное дерево
            состояния приложения.</b></p>

            <p>Каким образом вы будете структурировать главный редюсер, зависит только от Вас. Redux поставляется с
            хелпером <mark>combineReducers()</mark>, полезным для «разделения» главного редюсера на отдельные функции,
            которые управляют отдельными ветвями дерева состояния. <mark>combineReducers()</mark> работает следующим
            образом. Допустим, у Вас есть два редюсера: один для списка todo-дел, второй — для выбранного сейчас режима
            отображения этого списка:</p>

            <pre><code class="language-jsx">
                function todos(state = [], action) {
                    // как-то вычисляет nextState...
                    return nextState
                }

                function visibleTodoFilter(state = 'SHOW_ALL', action) {
                    // как-то вычисляет nextState...
                    return nextState
                }

                let todoApp = combineReducers({
                    todos,
                    visibleTodoFilter
                })
            </code></pre>

            <p>Когда вы инициируете действие, todoApp, которое вернул <mark>combineReducers</mark>, вызовет оба
            редюсера:</p>

            <pre><code class="language-jsx">
                 let nextTodos = todos(state.todos, action)
                 let nextVisibleTodoFilter = visibleTodoFilter(state.visibleTodoFilter, action)
            </code></pre>

            <p>Затем оба набора состояний будут снова собраны в единое состояние:</p>

            <pre><code class="language-jsx">
                 return {
                    todos: nextTodos,
                    visibleTodoFilter: nextVisibleTodoFilter
                 }
            </code></pre>

            <p>Так как <mark>combineReducers()</mark> — это просто удобная утилита, вы совершено не обязаны ее
            использовать. Вы можете написать главный редюсер самостоятельно.</p>
        </li>
        <li>
            <p><b>Хранилище Redux сохраняет полное дерево состояния, которое возвращает главный редюсер.</b></p>
            <p>Это новое дерево является следующим состоянием Вашего приложения! Каждый слушатель, зарегистрированный с
            помощью <mark>store.subscribe(listener)</mark>, будет вызван. Слушатели могут вызывать
            <mark>store.getState()</mark> для получения текущего состояния приложения.</p>
            <p>Теперь UI может быть обновлен для отражения нового состояния приложения. Если вы используете такие
            биндинги, как React Redux, то это та точка, в которой стоит вызвать
            <mark>component.setState(newState)</mark></p>
        </li>
    </ol>

    <div class="lr-btn">
        <button class="atuin-btn" onclick="window.location.href = '../../redux/store/index.html';"><i class="fa fa-chevron-circle-left" aria-hidden="true"> </i><span>_</span>Назад</button>
        <button class="atuin-btn" onclick="window.location.href = '../../redux/usage-with-react/index.html';">Далее<span>_</span><i class="fa fa-chevron-circle-right" aria-hidden="true"></i> </button>
    </div>
</div>

</body>
</html>
