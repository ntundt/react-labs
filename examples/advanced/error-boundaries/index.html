<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Границы ошибок подробнее</title>

    <link rel="stylesheet" href="../../../../web-page/css/header.css">
    <link rel="stylesheet" href="../../../../web-page/css/content.css">
    <link rel="stylesheet" href="../../../libraries/prism.css">

    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>

    <script src="../../../libraries/prism.js"></script>

</head>
<body>

<div class="header">
    <a href="./../../../examples.html" class="logo">
        <img src="../../../../web-page/images/react-logo.png">
        <p>React.js</p>
    </a>
    <div class="header-right">
        <a href="../../../../web-page/index.html">React.js</a>
        <a href="../../../../web-page/examples.html">Содержание</a>
        <a href="../../../../web-page/info.html">Информация</a>
    </div>
</div>
<div id="delimiter"></div>

<div class="content">
    <p class="section">Границы ошибок</p>
    <p>Ранее ошибки JavaScript внутри компонентов, ломали внутреннее состояние React и вынуждали его выбрасывать загадочные ошибки на последующих отрисовках. Эти ошибки всегда были вызваны более ранней ошибкой в коде приложения. React не предоставлял способа их грамотно обработать в компонентах и не мог восстановиться после того, как эти ошибки возникли.</p>

    <p class="section">Знакомство с границами ошибок</p>
    <p>Ошибка JavaScript в области пользовательского интерфейса не должна ломать все приложение. Чтобы решить эту проблему для пользователей React, React 16 представляет новую концепцию «граница ошибки».</p>
    <p>Границы ошибок - это компоненты React, которые отлавливают ошибки JavaScript в любом месте их дочернего дерева компонентов, регистрируют эти ошибки и отображают резервный интерфейс вместо поломанного дерева компонентов. Границы ошибок перехватывают ошибки во время отрисовки, в методах жизненного цикла и в конструкторах всего дерева под ними.</p>
    <p>Компонент класса становится границей ошибки, если он определяет новый метод жизненного цикла, называемый componentDidCatch (error, info):</p>

    <pre><code class="language-js">
    class ErrorBoundary extends React.Component {
    constructor(props) {
      super(props);
      this.state = { hasError: false };
    }

    componentDidCatch(error, info) {
      // Отображение резервного UI
      this.setState({ hasError: true });
      // Вы можете прологировать ошибку с помощью сервиса отчета об ошибках
      logErrorToMyService(error, info);
    }

    render() {
      if (this.state.hasError) {
        // Вы можете отрисовать любой резервный UI
        return <h1>Возникли ошибки.</h1>;
      }
      return this.props.children;
    }
  }
        <CustomButton color="red"/>
    </code></pre>

    <p>Затем вы можете использовать его как обычный компонент:</p>

    <pre><code class="language-js">
  &lt;ErrorBoundary>
    &lt;MyWidget />
  &lt;/ErrorBoundary>
        <CustomButton color="red"/>
    </code></pre>
    <p>Метод componentDidCatch () работает как блок catch {} JavaScript, но для компонентов. Только компоненты класса могут являться границами ошибок. На практике вы скорее всего предпочтёте объявить компонент границы ошибки один раз и использовать его во всем приложении.</p>
    <p>Обратите внимание, что граница ошибки отлавливает только ошибки в компонентах ниже их в дереве. Граница ошибки не может отловить ошибку внутри себя. Если текущая граница ошибки проваливает попытку отобразить сообщение об ошибке, ошибка будет распространяться на ближайшую границу ошибки выше по дереву иерархии. Это тоже похоже на то, как блок catch {} работает в JavaScript.</p>

    <p class="section">Параметры componentDidCatch</p>
    <p>error - это ошибка, которая была выброшена.</p>
    <p>info - это объект с ключом componentStack. Свойство содержит информацию о стеке компонентов во время выбрасывания ошибки.</p>
    <pre><code class="language-js">
  //...
  componentDidCatch(error, info) {

    /* Пример информации о стеке:
       in ComponentThatThrows (created by App)
       in ErrorBoundary (created by App)
       in div (created by App)
       in App
    */
    logComponentStackToMyService(info.componentStack);
  }
  //...
        <CustomButton color="red"/>
    </code></pre>
    <p class="section">Где устанавливать границы ошибок</p>
    <p>Расположение границ ошибок зависит от вас. Вы можете обернуть компоненты верхнего уровня, чтобы отобразить сообщение типа «Что-то пошло не так» для пользователя, так же как серверные фреймворки часто обрабатывают сбои. Вы также можете обернуть отдельные виджеты в границу ошибки, чтобы защитить их от поломки остальной части приложения.</p>
    <p class="section">Новое поведение для необрабатываемых ошибок</p>
    <p>Это изменение имеет важное значение. Начиная с React 16, ошибки, которые не были захвачены какой-либо границей ошибок, приведут к демонтированию всего дерева компонентов React.</p>
    <p>Мы обсуждали это решение, но по нашему опыту полностью удалить поврежденный пользовательский интерфейс, чем оставить его видимым. Например, в таком продукте, как Messenger, если оставить сломанный пользовательский интерфейс видимым, это может привести к тому, что кто-то отправит сообщение не тому человеку. Аналогично, для приложения платежей лучше ничего не отображать, чем отображать неправильную сумму.</p>
    <p>Это изменение означает, что как только вы мигрируете на React 16, то, вероятно, обнаружите сбои в своем приложении, которые были незаметны раньше. Добавление границ ошибок позволяет обеспечить лучший UX, когда что-то пойдет не так.</p>
    <p>Например, Facebook Messenger обертывает содержимое боковой панели, информационной панели, журнала беседы и поля ввода сообщения в отдельные границы ошибок. Если какой-то компонент в одной из этих областей пользовательского интерфейса ломается, остальные продолжают исправно работать.</p>
    <p>Мы также рекомендуем вам использовать сервисы отчетов об ошибках JS (или создать свои собственные), чтобы вы могли узнавать о необработанных исключениях, которые происходят в production версии, и исправлять их.</p>

    <p class="section">Трассировка стека компонентов</p>
    <p>Во время разработки React 16 печатает все ошибки, возникающие при рендеринге в консоль, даже если приложение случайно проглатывает их. Помимо сообщения об ошибке и стека JavaScript, он также обеспечивает трассировку стека компонентов. Теперь вы можете увидеть, где именно в дереве компонентов произошла ошибка:</p>
    <img src="../portals/error1.png"/>
    <p>Вы также можете увидеть имена файлов и номера строк в трассировке стека компонентов. Это работает по умолчанию в проектах Create React App :</p>
    <img src="../portals/error2.png"/>
    <p>Если вы не используете приложение Create React App , вы можете добавить этот плагин вручную в свою конфигурацию Babel. Обратите внимание, что он предназначен только для development версии приложения и должен быть отключен в production версии.</p>

    <p class="section">Почему не try/catch?</p>
    <p>try/catch хорош, но он работает только для императивного кода:</p>
    <pre><code class="language-js">
  try {
    showButton();
  } catch (error) {
    // ...
  }
        <CustomButton color="red"/>
    </code></pre>
    <p>Однако компоненты React являются декларативными и указывают, что должно быть отображено:</p>
    <pre><code class="language-js">
           &lt;Button />
        <CustomButton color="red"/>
    </code></pre>
    <p>Границы ошибок сохраняют декларативную природу React и ведут себя так, как вы ожидаете. Например, даже если ошибка, вызванная setState, происходит в методе componentDidUpdate где-то глубоко в дереве, она все равно будет правильно распространяться к ближайшей границе ошибки.</p>

    <p class="section">Как насчет обработчиков событий?</p>
    <p>Границы ошибок не отлавливают ошибки внутри обработчиков событий.</p>
    <p>React не нуждается в границах ошибок внутри обработчиков событий, чтобы восстановиться от этих ошибок. В отличие от методов отрисовки и жизненного цикла, обработчики событий не вызываются во время отрисовки. Поэтому, если обработчики выбрасывают ошибки, React все еще знает, что отображать на экране.</p>
    <p>Если вам нужно поймать ошибку внутри обработчика событий, используйте обычный оператор try/catch JavaScript:</p>

    <pre><code class="language-js">
  class ErrorCapturer extends React.Component {
    constructor(props) {
      super(props);
      this.state = { error: null };
    }

    onClick = () => {
      try {
        // Выполните что-то, что выбросит ошибку
      } catch (error) {
        this.setState({ error });
      }
    }

    render() {
      if (this.state.error) {
        return &lt;h1>Ошибка перехвачена!.&lt;/h1>
      }
      return &lt;div onClick={this.onClick}>Нажать&lt;/div>
    }
  }
        <CustomButton color="red"/>
    </code></pre>
    <p>Обратите внимание, что приведенный выше пример демонстрирует стандартное поведение JavaScript и не использует границы ошибок.</p>
    <div class="button">
    <a href="../../advanced/portals/">&laquo; Назад</a>
    <a class="next" href="../../advanced/web-components/">Далее &raquo;</a>
    </div>
</div>

</body>
</html>