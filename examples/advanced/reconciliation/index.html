<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Согласование</title>

    <link rel="stylesheet" href="../../../../web-page/css/header.css">
    <link rel="stylesheet" href="../../../../web-page/css/content.css">
    <link rel="stylesheet" href="../../../libraries/prism.css">

    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>

    <script src="../../../libraries/prism.js"></script>

</head>
<body>

<div class="header">
    <a href="./../../../examples.html" class="logo">
        <img src="../../../../web-page/images/react-logo.png">
        <p>React.js</p>
    </a>
    <div class="header-right">
        <a href="../../../../web-page/index.html">React.js</a>
        <a href="../../../../web-page/examples.html">Содержание</a>
        <a href="../../../../web-page/info.html">Информация</a>
    </div>
</div>
<div id="delimiter"></div>

<div class="content">

    <p class="section">Согласование</p>

    <p>React предоставляет декларативный API, так что вам не нужно беспокоиться о том, какие именно изменения происходят
        при каждом обновлении. Это значительно упрощает написание приложений, но может быть неочевидно, как это
        реализовано в React. В этой статье объясняются подходы, которые реализовали разработчики в алгоритме React,
        чтобы обновления компонентов были предсказуемыми, будучи достаточно быстрыми для высокопроизводительных
        приложений.</p>

    <p class="section">Мотивация</p>

    <p>Когда вы используете React, в определенный момент времени вы можете думать о функции render () как о создателе
        дерева элементов React. При следующем обновлении состояния или свойств функция render () вернет другое дерево
        элементов React. После этого React необходимо выяснить, как эффективно обновить пользовательский интерфейс,
        чтобы соответствовать последнему дереву.</p>

    <p>Существуют некоторые общие решения этой алгоритмической задачи генерации минимального количества операций для
        преобразования одного дерева в другое. Однако современные алгоритмы имеют сложность порядка O(n3), где n -
        количество элементов в дереве.</p>

    <p>Если использовать это в React, то для отображения 1000 элементов потребуется порядка одного миллиарда сравнений.
        Это слишком дорого. Вместо этого React реализует эвристический алгоритм O(n), основанный на двух
        предположениях:</p>

    <ul>
        <li><span>• </span>Два элемента разных типов будут создавать разные деревья.</li>
        <li><span>• </span>Разработчик может указать, какие дочерние элементы могут быть стабильными между разными
            отрисовками с
            помощью свойства key.
        </li>
    </ul>

    <p>На практике эти предположения применимы почти для всех практических случаев.</p>

    <p class="section">Алгоритм сравнения</p>

    <p>При сравнении двух деревьев, React сначала сравнивает два корневых элемента. Поведение различно в зависимости от
        типов корневых элементов.</p>

    <div class="button">
        <a href="../../advanced/react-without-jsx">&laquo; Назад</a>
        <a class="next" href="../../advanced/context">Далее &raquo;</a>
    </div>

</div>

</body>
</html>